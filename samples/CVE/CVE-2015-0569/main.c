// RUN: %clang -fcheckedc-extension -Xclang -verify -o %t.exe %s
// RUN: --crash %t.exe %S/CVE20150569.in
// expected-no-diagnostics

/* CVE-2015-0569
   Heap-based buffer overflow in the private wireless extensions IOCTL implementation in wlan_hdd_wext.c 
   in the WLAN (aka Wi-Fi) driver for the Linux kernel 3.x and 4.x, as used in Qualcomm Innovation Center
   (QuIC) Android contributions for MSM devices and other products, allows attackers to gain privileges v-
   ia a crafted application that establishes a packet filter.  
*/

#include "../../../include/stdio_checked.h"
#include "../../../include/stdlib_checked.h"
#include "../../../include/string_checked.h"
#include "wlan_hdd_cfg_checkedc.h"

static inline int copy_from_user(void *dst, const void *src, int size)
{
    memcpy(dst,src,size);
    return 0;
}

/* MODIFICATION FOR CHECKEDC */
// CHECKEDC - bounds-safe interface (unchecked pointer type + bounds information declaration)
// According to call-site action, its type is determined

/* Currently we write checkedc_memcpy fuc, but we can re-write with interoperation */
/* static inline void checkedc_memcpy(void* dst : byte_count(size), const void* src : byte_count(size), int size) */
static inline void checkedc_memcpy(array_ptr<void> dst : byte_count(size), array_ptr<const void> src : byte_count(size), int size)
{
    memcpy(dst, src, size);
}

void *mem_alloc_copy_from_user_helper(const void *wrqu_data, size_t len)
{
    u8 *tmp = NULL;
    tmp = (u8*) malloc(len+1);

    copy_from_user(tmp, wrqu_data, len);
    tmp[len]='\0';
    return tmp;
}

int wlan_hdd_set_filter(hdd_context_t *pHddCtx, tpPacketFilterCfg pRequest)
{
    int i=0;
    tSirRcvPktFilterCfgType packetFilterSetReq = {0};

    switch(pRequest->filterAction)
    {
    case HDD_RCV_FILTER_SET:
        for(i=0; i<pRequest->numParams;i++)
        {
            packetFilterSetReq.paramsData[i].protocolLayer = pRequest->paramsData[i].protocolLayer;
            packetFilterSetReq.paramsData[i].cmpFlag = pRequest->paramsData[i].cmpFlag;
            packetFilterSetReq.paramsData[i].dataOffset = pRequest->paramsData[i].dataOffset;
            packetFilterSetReq.paramsData[i].dataLength = pRequest->paramsData[i].dataLength;
            packetFilterSetReq.paramsData[i].reserved=0;
            /* MODIFICATION FOR CHECKEDC */
            // CHECKEDC - function call validity check (ch.4.2.4)
            // check that all actual arugments corresponding to the formal parameters
            // are valid non-modifying bounds expression
            // LHS (formal parameter) = RHS (actual argument), bounds(LHS) <= bounds(RHS)
            // LHS (byte_count(size), dataLength) <= RHS (count(8), checked[8])

            // Possible to check at runtime?? ( Compile is OK --> check at runtime )

            /* dynamic_check(pRequst->paramsData[i].dataLength < 8) */
            checkedc_memcpy(packetFilterSetReq.paramsData[i].compareData, pRequest->paramsData[i].compareData, pRequest->paramsData[i].dataLength);
            printf("dataLength = %d, paramsData[%d].compareData[%d]=%d\n",pRequest->paramsData[i].dataLength, i, (pRequest->paramsData[i].dataLength)-1,
                   packetFilterSetReq.paramsData[i].compareData[(pRequest->paramsData[i].dataLength)-1]);

            /* MODIFICATION FOR CHECKEDC */
            // CHECKEDC - function call validity check (ch.4.2.4)

            /* dynamic_check(pRequst->paramsData[i].dataLength < 8) */
            checkedc_memcpy(packetFilterSetReq.paramsData[i].dataMask, pRequest->paramsData[i].dataMask, pRequest->paramsData[i].dataLength);
            printf("dataLength = %d, paramsData[%d].dataMask[%d]=%d\n",pRequest->paramsData[i].dataLength, i, (pRequest->paramsData[i].dataLength)-1,
                   packetFilterSetReq.paramsData[i].dataMask[(pRequest->paramsData[i].dataLength)-1]);
        }
        break;
    default:
        return -1;
    }

    return 0;
}


void* set_data(char **argv, struct iw_point *priv_data, hdd_context_t *pHddCtx)
{
    FILE *fd;
    u32 rd_size;
    char ch;
    char *file_name;
    file_name = argv[1];
    u8 *tmp = NULL;
    fd = fopen(file_name, "r");

    tmp = malloc(BUF_LEN*sizeof(u8));
    
    memset(tmp,0,BUF_LEN*sizeof(u8));

    int j=0;
    int in;
    while(!feof(fd))
    {
        fscanf(fd, "%d",&in);
        tmp[j]=(u8)in;
        j++;
    }

    fclose(fd);

    priv_data->pointer = tmp;
    priv_data->length = 85*sizeof(u8);
    priv_data->flags=1;

    pHddCtx->hdd_restart_retries = 1;
    pHddCtx->max_num_tdls_sta = 3;

    return tmp;
}

int main(int argc, char **argv)
{

    u8 *test_buffer;
    tpPacketFilterCfg pRequest = NULL;
    int ret;
    struct iw_point priv_data;
    hdd_context_t pHddCtx;

    /* Generate random priv_data */
    test_buffer=set_data(argv, &priv_data, &pHddCtx);
    /* NEED TO GEN priv_data.pointer, priv_data.length */

    pRequest = mem_alloc_copy_from_user_helper(priv_data.pointer, priv_data.length);
    
    ret = wlan_hdd_set_filter(&pHddCtx, pRequest);

    free(pRequest);

    free(test_buffer);
    return ret;

}
