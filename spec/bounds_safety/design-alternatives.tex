% !Tex root = checkedc.tex

\chapter{Rejected design choices}
\label{chapter:design-alternatives}

This chapter describes design choices that we considered and rejected.
A separate chapter is useful for three reasons.   First, it makes it 
easier to learn the existing design because there is less to read.
Second, it provides reasons for why the current
design choices were made.  Third, as we gather experience with the current
design, we may want change the design choices that we made. 
This chapter provides a starting point 
of alternative designs.  For example, support for non-relatively 
aligned pointers originally started in this chapter as a rejected design choice. 
After looking at OpenSSL code that
used pointer casts, we changed our mind and incorporated
the material into the main design.

\section{Alternate syntax for pointer types}
\label{section:alternate-pointer-type-syntax}

Instead of using the C++ template instantiation syntax, we
considered allowing the new pointer names to be used in place of \code{*}.
For example, given a declaration of the form \code{int *pi;}, this could be changed
to declare a \code{ptr} to an integer by substituting \code{ptr} for \code{*},
producing \code{int ptr pi;}.
  
This seems to make code less readable.  This is apparent for type names that 
consist of several words: \code{const unsigned int ptr g} is more
difficult to parse quickly than \ptrinst{\lstinline|const unsigned int|} \code{g}.
The use of symbols like \code{<} and \code{>} can be recognized 
visually more quickly than the use  of an identifier.  

Another possible approach is to treat the new kinds
of pointer types  as new modifiers for pointers.  For example, 
\code{int * ptr pi;} would declare a \code{ptr} to an integer. This is 
also difficult to parse and makes code even more verbose.

A drawback to using C++ template instantiation syntax is that it interacts
poorly with mixed C declarators. In the syntax of C declarators, \code{*} is used as
a prefix to an identifier to modify the type of an identifier. A mixed
declarator is a declarator where different identifiers have different
types because of different modifiers. An example of a mixed declarator
is the declaration \code{int i, *pi;}. The C++ template instantiation produces a
type, so ``mixed'' declarators must be broken across multiple
lines instead. The resulting declarations would be 
\code{int i;} \ptrint\ \code{pi;} On the other hand, non-mixed
declarators are fine: \code{int *pj, *pi;} becomes
\ptrint\ \code{pi, pj;}.

\section{Span pointer types}
\label{section:span-design}

We considered introducing a type called \spanptr\ for pointer types that carry their bounds with
them dynamically.  We decided to postpone this for now because \spanptr\ is a type that
seems appropriate to be defined in a library. The \spanptr\ type can be implemented using
\arrayptr\ types, but not {\it vice versa}.   The main issue is that C does not provide support
for generic types.
Indeed, in C++, which has templates, a \spanptr\ type has already been proposed for the C++
Standard Library \cite{Macintosh2016}.
While the name \spanptr\ is new,
the idea of a span type itself dates back to the early days of computer science.
A \spanptr\ is an instance of a  dope vector, which is a data structure
that describes the shape of an array.  Dope vectors were used in
implementations of ALGOL60 \cite{Sattley1961}.

In our proposal, a \spanptrT\ pointer would carry three values with it: the memory location that
will be accessed by dereferencing the \spanptrT, a lower
bound on the memory that can be accessed via the current pointer value,
and an upper bound on accessible memory. Those values can be accessed
using the \code{.} operator combined with the special field names
\code{current}, \code{lower_bound}, and \code{upper_bound}. The
resulting values have the type
\arrayptrT. The
special field names can only be read and cannot be modified by
assignments.

\begin{lstlisting}
span<int> p = ...
array_ptr<int> low = p.lower_bound;
array_ptr<int> high = p.upper_bound;
array_ptr<int> current = p.current;
\end{lstlisting}

The operations on a \spanptr\ would be similar to those on \arrayptr, except that
the dynamic bounds values would be used:
\begin{itemize}
\item  Indirection: the \code{*} operator could be applied also to a value of type \spanptrT.
It would produce a value of type \var{T}
\item
 Array reference: the \code{[]} operator could be applied also to a
  value of type \spanptrT.   \var{e1}\lstinline|[|\var{e2}\lstinline|]| is equivalent to
  \lstinline|*(|\var{e1} \lstinline|+| \var{e2}\lstinline|)|.
\item Pointer arithmetic: adding or subtracting a value of \spanptr\ pointer type and an integer
      would be allowed. Pointer arithmetic overflow would be considered a runtime error.
\end{itemize}

A \spanptrT\ value would be created by casting a value of another pointer type to the
\spanptrT\ type. A
value of another pointer type could be converted implicitly to an
\spanptrT\ in
situations where a
\spanptrT\ value is
expected, the referent type of the other pointer type is \var{T}, and
the bounds of the value can be determined automatically.

For example, a variable of array type could be converted automatically to
a \spanptr. First, the array type would be converted to a
pointer type of either \var{T} \code{*} or
\arrayptrT , depending
on whether the array type is checked or unchecked. This pointer type
would then be converted to an
\spanptrT. The
bounds of a variable of array type are easily determined at compile
time, so the pointer type would then be converted to an
\spanptrT:

\begin{lstlisting}
int x[10]
span<int> p = x;
// p.current = x; p.lower_bound = x; p.upper_bound = x + 10;

\end{lstlisting}

Similarly, an \arrayptr\ value with declared bounds can be
converted implicitly to a \spanptr\ value:

\begin{lstlisting}
array_ptr<int> src = ...
span<int> p = src;
\end{lstlisting}

The operators for casting in Section~\ref{section:pointer-casting} would be expanded
to have rules that treat \spanptr\ values similarly to \arrayptr\ values.

Having \spanptr\ values carry lower bounds is an important difference between our
proposal and the C++ proposal.   In the proposed C++ design, \spanptr\ values
carry counts of elements.  The C++ proposal does not
support decrementing the \spanptr.   For symmetry with \arrayptr, we think it
would be important in the Checked C extension that \spanptr\ values carry lower bounds.

\section{Address-of operations and array-to-pointer conversions always produce checked pointer types}

We considered a design where the address-of operator (\&) and
array-to-pointer type conversions always produce checked pointer types. To
preserve compatibility with existing C code, we would introduce implicit
conversions from checked pointers to unchecked pointers. We found that we were
not able to preserve backwards compatibility for the address-of operator
and that implicit array-to-pointer conversions required bounds checking.

\subsection{Address-of operator rules}

The address-of operator (\code{&}) applied to an lvalue expression of
type \var{T} would produce a value of type
\ptrT.

Existing C code expects the address-of operator to produce a \var{T} *.
To allow most code to compile without changes, we add an implicit cast
rule: \ptrT\ can be cast
implicitly to a \uncheckedptrT\ in those situations where a \uncheckedptrT\ 
type is expected, except for pointer arithmetic operators
that add or subtract a pointer and an integer. Those situations include
pointer assignment, arguments to function calls, return statements, and
conditional expressions. In all these situations a \uncheckedptrT\
type must have been declared explicitly in the code already, so this
implicit cast does not introduce unchecked pointer types where none existed
before.

Pointer arithmetic operators are excluded to avoid the silent
introduction of unchecked pointer types and to preserve the value of having
the \ptrT\ type. If
there were always an implicit cast from \ptrT\ to \uncheckedptrT,
then any expression that uses pointer arithmetic could do pointer
arithmetic on \ptrT\
values.

Code takes the address of an array element and immediately does pointer
arithmetic will still fail to type check, introducing a potential
backward compatibility issue:
\begin{lstlisting}
f(void)
{
    int a[10];
    int *x = &a[0] + 5; // &a[0] has type ptr<T>.  Pointer arithmetic is not allowed
    ...
}
\end{lstlisting}

We expect this kind of code to be rare because the succinct style is to
use \code{a} instead of \code{&a[0]}, but it is nonetheless a
possibility, so this proposal still violates the principle of not
changing the meaning of existing C code.

\begin{lstlisting}
f(void)
{
    int a[10];
    int *x = ((int *) &a[0]) + 5; // redundant but OK under old rule
    ...
}
\end{lstlisting}

\subsection{Array-to-pointer conversion rules}

Array types may be complete or incomplete. A complete array type
specifies the number of elements in the array using a constant
expression. In incomplete array type does not specify the number of
elements in the array. Examples of complete array types are 
\code{int[10]}
and \code{int[10][10]}. Examples of incomplete array types are
\code{int[]} and \code{int[][10]}.

If the type of an expression or a subexpression is an ``array of
\var{T}'', the following rules would apply. If the array is a complete
type, the type of the expression is altered to
\arrayptrT. If it is
an incomplete type, the type of the expression is altered to \var{T} *.
This alteration does not happen if the expression is an operand of an
address-of operator, \code{++}, \code{--}, \code{sizeof}, or the
left operand of an assignment operator or the `\code{.}' operator.

These rules would have an interesting effect for arrays of complete
types: all array references involving those arrays would be bounds
checked. Any address computations involving those arrays will be checked
for overflow also. Because the existing C language definition leaves
out-of-bounds access of arrays of complete type undefined, as well as
the meaning of overflowing address computations undefined, this is
compatible with the existing C language definition.

However, these rules by themselves are problematic for existing C code.
It is common in C code to use array types interchangeably with pointer
types. The rule that complete array types are converted to
\arrayptr\ types could cause problems for such code

\begin{lstlisting}
f(int *arg, int len)
{ 
   ...
}

g(void) {
   int x[10];
   f(x, 10);
}

h(void) {
   int x[10];
   int *ptr = x;
   f(ptr, 10);
}
\end{lstlisting}

To allow existing code to continue to compile unchanged, we adopt the
rule that an \arrayptrT\ can be
implicitly cast to a \var{T} * in situations where a \var{T} * type is
expected. Those situations may include pointer assignment, arguments to
function calls, return statements, and conditional expressions. For
onditional, expressions of the form \var{exp1} \code{?} \var{exp2} \code{:}
\var{exp3}, the implicit coercion occurs when \var{exp2} or \var{exp3} has type \var{T} * and
the other expression has type
\arrayptrT. These situations do not
include array references and adding or subtracting a pointer type and an
integer. \arrayptrT\ is an acceptable
type for those operations and a coercion to \var{T} * is not needed.

We allow \arrayptr\ values to not be within bounds. Because of
this, any implicit conversion of an \arrayptr\ value with a
bounds to an unchecked pointer type must be bounds checked. Otherwise, it
is easy to write ``checked'' code that creates undetected buffer overruns:

\begin{lstlisting}
// f looks like it is correct, but does something bad that is
// undetected before calling unchecked code
f(array_ptr<int> p where p : bounds(p, p + 10))
{
    // first argument implicitly converted to int *
    poke(p + random_large_value(), 31415);  
}

void poke(int *p, int val)
{
    *p val
}
\end{lstlisting}

The silent introduction of a bounds check at a call to a method violates
the design principles of control and clarity. The implicit conversion
introduces an invisible failure point in a program where one does not
otherwise exist. Pointer arithmetic is not normally bounds checked, so
it is not expected fail.

\section{Alternate bounds for the address-of operator applied to a pointer dereference}
\label{section:alternate-address-of-pointer-bounds}

The bounds for \lstinline|&*|\var{e} are defined to be the bounds of \var{e} in 
Section~\ref{section:address-of-expression-bounds}.  We considered
using narrower bounds for \lstinline|&*|\var{e} of \bounds{\var{e}}{\var{e}\code{\ + 1}},
where the bounds describe memory containing only a single value.
We rejected this choice for two reasons.

First, the narrower bounds use \var{e}.  This is a problem because expressions used within
bounds expressions must be non-modifying expressions. These are a subset of C expressions that do 
not modify variables or memory.  The expression \var{e} might not be a valid non-modifying 
expression, in which case there would be no way to write the narrower bounds expression.  We could try to restrict \lstinline|&*|\var{e} so that \var{e} must be a non-modifying expression.  We do not know
the extent of changes that this could require in existing C programs.

Second, the meaning of \lstinline|&*|\var{e} is ambiguous in C.   This ambiguity often
arises when programmers take the address of array elements: \lstinline|&|\var{e1}\lstinline|[|\var{e2}\lstinline|]|
is a synonym for \lstinline|&*|\lstinline|(|\var{e1}\lstinline|+|\var{e2}\lstinline|)|.  It is not clear whether
programmers mean to refer to single elements or multiple elements of arrays.
In some cases, programmers mean
to refer to only single elements:
\begin{lstlisting}
void swap(int *p, int *q) {
    tmp = *p;
    *p = *q;
    *q = *tmp;
}

void f(void) {
    int arr[5] = {0, 1, 2, 3, 4};
    swap(&arr[0], &arr[5]);
}
\end{lstlisting}

In other cases, programmers mean to refer to a range of elements:
\begin{lstlisting}
int sum(int *start, int count) {
   int total = 0;
   for (int i = 0; i < count; i++) {
       total += start[i];
   }
   return total;
}

void f(void) {
    int arr[5] = {0, 1, 2, 3, 4};
    sum(&arr[3], 3);
}
\end{lstlisting}

C provides no way to differentiate between the two cases. 
This leads us to choose the more general bounds (the wider bounds).
A programmer can always narrow the bounds if desired.  The converse is not
true.

Some programming languages provide the notion of array slices and have syntax for slices. 
An array slice is a sub-section of an array with a designated beginning and ending.
However, extending C with new syntax for array slices would violate the design
principle of minimizing changes to C.

\section{Alternate semantics for bounds declarations}
\label{section:bounds-declarations-alternate-semantics}

There are a variety of possible semantics for
bounds declarations. A bounds declaration has the form:

\begin{quote}
\boundsdecl{\var{x}}{\var{bounds-exp}}
\end{quote}

\begin{tabbing}
\var{bounds}\=\var{-exp:} \\
\> \code{count(}\var{non-modifying-exp}\code{)} \\
\> \bounds{\var{non-modifying-exp}}{\var{non-modifying-exp}} \\
\> \boundsunknown \\
\> \boundsany
\end{tabbing}

It may be attached to declarators, parameter declarations, or assignment statements:

\begin{tabbing}
\var{init-}\=\var{declarator:} \\
\>\var{declarator inline-bounds-specifier\textsubscript{opt} where-clause\textsubscript{opt}} \\
\>\var{declarator inline-bounds-specifier\textsubscript{opt} 
where-clause\textsubscript{opt}} \code{=} \var{initializer
where-clause\textsubscript{opt}} \\
\>\ldots{} \\
\\
\var{parameter-declaration:} \\
\>\var{declaration-specifiers declarator} \\
\>\var{inline-bounds-specifier\textsubscript{opt} where-clause\textsubscript{opt}} \\
\\
\var{expression-statement:}\\
\>\var{expression\textsubscript{opt} where-clause\textsubscript{opt}}\code{;}
\end{tabbing}

The information in the bounds declaration is used at pointer
dereferences involving either (1) the variable or (2) pointers
constructed from the value of the variable.

One design choice for bounds declarations is when
bounds expressions are evaluated.  In the design, evaluation of
bounds expressions is {\em deferred} until bounds checks.  The bounds
expressions could be evaluated {\em eagerly} at the point of the bounds declarations.

If bounds expressions in a bounds declaration \boundsdecl{\var{v}}{\var{e}} are evaluated 
eagerly, they must  be evaluated only when \var{v} is non-null. If \var{v} is null,
the bounds might not be meaningful.  This keeps eager evaluation from
causing accidental runtime failures when null values are encountered.    

Consider the code for the use of \code{malloc}.   With eager evaluation,
the bounds expressions in \bounds{\code{result}}{\code{result + size}} would not
be evaluated if \code{malloc} returns \code{null}:
\begin{lstlisting}
array_ptr<int> result = malloc(size) where result : bounds (result, result + size);
if (result != NULL) {
      ... *result = ...
}
\end{lstlisting}

We considered eager evaluation, but rejected it because it would turn \arrayptr\
types into \spanptr\ types.  When bounds expressions are always eagerly
evaluated, the results need to be stored somewhere so that they can be used
when \var{v} is used.  For local variables, hidden temporary variables could be
introduced.  This breaks the design principle of not introducing hidden
costs, though.  To avoid introducing hidden costs, the semantics of \arrayptr\ types could 
be changed so that they carry their bounds with them.   This just turns \arrayptr\ types into 
\spanptr\ types.   For structures, introducing hidden state or converting \arrayptr\ types to 
\spanptr\ types is especially problematic because it breaks data layout compatibility.

For these reasons, we think it is better to think of bounds declarations as being
program invariants describing the bounds of variables.   Normally, 
program invariants are not evaluated at runtime.  However, in the case of pointers,
the program invariants are used to provide bounds safety at runtime.

Deferred evaluation of bounds expressions has issues, too, though. First, there
can be problems if a programmer modifies a variable used in a bounds expression
within the extent of a bounds declaration.  Static checking could fail if the
bounds declaration no longer holds.  These would be unexpected errors for
C progammers.  Second, it is a new concept for C programmers that could
cause confusion.  We recommend a study of
programmers to evaluate the difficulty of learning the concept.

Because bounds declarations constrain assignments to variables within the scope
of the bounds declarations, we considered several alternate definitions of 
bounds declarations.   First, we considered not having lexically-scoped bounds
declarations and just having flow-sensitive bounds declarations.  Flow-sensitive
bounds declarations are more subtle to understand, though, while lexically-scoped
bounds declarations can be understood at a glance.  We decided to keep
lexically-scoped bounds declarations because they are simpler to understand and
allow bounds invariants to be declared that always cover a set of statements.
In contrast, with only flow-sensitive bounds declarations, a programmer might need 
to redeclare the bounds invariant at  assignments to variables that occur in the
bounds declaration. This could lead to verbose code, something C tries to
avoid, and it could also be error-prone.

We considered the opposite approach of having only lexically-scoped
bounds declarations.   However, this introduces the opposite problem of
redeclaring invariants.  A pointer variable could not have different
bounds declarations at different points in the program.  This could
make modifying existing C code to be bounds-safe more complex: an existing
variable might need to be replaced with several new variables.

Finally, we considered several alternate definitions of the extent of a
flow-sensitive bounds declaration for a pointer variable:
\begin{compactitem}
    \item Defining extent to be the set of statements up to the first assignment
          to any variable occurring in the bounds declaration.   This is a
          ``minimal'' notion of extent.  It removes the special case for
          pointer increment and decrement, so bounds
          declarations would be required at those statements.  We believe
          the special case will lead to more succinct code, so we chose to
          keep it.
    \item Defining extent to be all the statements between the bounds
          declaration and the next bounds declaration for
         the pointer variable or the last use of the pointer variable.  This
         is a ``maximal'' notion of extent.  We thought this case might
         lead to surprising error messages when modifying existing
         code.  In particular, with this definition, extending
         the lifetime of a pointer variable could lead to errors
         at assignments within the new part of the lifetime, specifically
         assignments to variables that occur in the bounds declaration.
         The current definition is more conservative.  It could produce errors
         only at new uses of the pointer variable or assignments in
         the new part of the lifetime that increment or decrement the pointer 
         variable.
  \item Adding special cases to the current definition beyond
        pointer increment and decrement.  
\end{compactitem}
We believe that we need experience using flow-sensitive bounds declarations
to choose between these different possible definitions of extent.

\section{Allowing pointer variables to be assigned values with no relationship to their bounds}

We considered allowing pointer variables to be assigned pointer values
not derived in some way from the object with which their bounds are
associated. The idea would be to avoid unnecessary restrictions on
operations involving pointers.

In this approach, the meaning of a bounds expression would be defined
differently than that given in Section~\ref{section:bounds-declarations}. 
The meaning would be the
following. Given an expression \var{e} with a bounds expression
\bounds{\var{lb}}{\var{ub}}, let the runtime
values of \var{e}, \var{lb}, and \var{ub} be \var{ev}, \var{lbv},
and \var{ubv}, respectively. If \var{ev} is not null, there will
always exist some object at runtime with the bounds (\var{low},
\var{high}) such that \var{low} \code{<=} \var{lbv}\ \&\&
\var{ubv} \code{<=} \var{high}. In other words, the
requirement is that expression bounds are always a subrange of the range
of memory for some valid object. This is provided that the value of the
expression with which those bounds are associated is non-null.

The problem with this approach is that it has unexpected consequences
for the bounds that can be declared for pointer variables.
Any valid pointer bounds could be declared for a variable because there
is no longer a requirement that a pointer stored in the variable be
derived from a pointer to the object associated with the bounds. The
following example would be valid:

\begin{lstlisting}
array_ptr<int> x : count(5) = malloc(sizeof(int) * 5);
array_ptr<int> y : bounds(x, x + 5) = malloc(sizeof(int) * 2);
\end{lstlisting}

This makes it more likely that programming errors involving bounds
declarations are detected only at runtime.   We did not pursue
this approach further for this reason.

\section{Function pointer casts}

The rules in Section~\ref{section:pointer-casting} for casting between function
pointers require that the bounds declarations on parameters and return values be
identical after conversions to canonical forms.   It is possible to have
more general rules around function pointer casts, at least from a checking
perspective.

For example, a function that expects an \arrayptr\ with 5 elements can
always be used in place of one that expects an \arrayptr\ with 10 elements.
This implies that a function pointer that expects an \arrayptr\ with 5
elements can be cast to a function pointer that expects an \arrayptr\ with
10 elements.  Similarly, a function that returns an \arrayptr\ with 10 elements
can always be used in place of a function that returns an \arrayptr\ with 5
elements.

More generally, a function with weaker preconditions can be used in place
of one with stronger preconditions.  A function with stronger post-conditions
can be used in place of a function with weaker post-conditions.

We chose not to generalize the rules for function pointer casts until we have
evidence from real-world experience that the generalization is needed.   It is
likely that we will to need to add support for weaker preconditions and stronger
post-conditions for \keyword{where} clauses on casts to function pointer types,
to avoid surprising programmers.  It is unclear whether this would be useful in
practice for bounds declarations on pointer types, or only of theoretical
interest.

\section{Null pointers and bounds expressions}

\newcommand{\objectbounds}[2]{\lstinline|object_bounds(|#1\lstinline|,| #2 \lstinline|)|}

The meaning of bounds expressions is conditional on values not being null. 
From Section~\ref{section:bounds-declarations}:
\begin{quote}
At runtime, given an expression \var{e} with a bounds expression
\bounds{\var{lb}}{\var{ub}}, let the runtime
values of \var{e}, \var{lb}, and \var{ub} be \var{ev}, \var{lbv},
and \var{ubv}, respectively. The value \var{ev} will be \code{0} (null) or
have been derived via a sequence of operations from a pointer to some
object \var{obj} with \bounds{\var{low}}{\var{high}}.
The following statement will be true at runtime:
\var{ev} \lstinline@== 0 || (@\var{low} \lstinline@<=@ \var{lbv} \lstinline@&&@
\var{ubv} \lstinline@<=@ \var{high}\lstinline@)@. 
\end{quote}

If \var{ev} is null, the bounds may or may not be valid.
This creates a problem.  Pointer arithmetic cannot be allowed
on null values.  If it were allowed, then
\boundsdecl{\var{e}}{\bounds{\var{lb}}{\var{ub}}} would
not imply \boundsdecl{\var{e} + \var{k}}{\bounds{\var{lb}}{\var{ub}}}, where \var{k} is
a non-zero constant.
Consider the counterexample where \var{ev} (the runtime value of \var{e}) is \code{0}.
For the first bounds expression, \var{ev} \lstinline@== 0 || (@\var{low} \lstinline@<=@ \var{lbv}
\lstinline@&&@ \var{ubv} \lstinline@<=@ \var{high}\lstinline@)@ is true. For the second bounds 
expression \var{ev} \lstinline@+@ \var{k} \lstinline@== 0 || (@\var{low} \lstinline@<=@ \var{lbv}
\lstinline@&&@\var{ubv} \lstinline@<=@ \var{high}\lstinline@)@ must be true.  We know that 
\var{ev} \lstinline@+@ \var{k} \lstinline@== 0@ is false, so
that means that the first bounds expression
must imply that \var{low} \lstinline@<=@ \var{lbv} \lstinline@&&@ \var{ubv} \lstinline@<=@ \var{high} is true. 
However, it does not: 
\var{A} \lstinline@||@ \var{B} does not imply \var{B}.

This is handled in the design by using runtime checking to prevent
pointer arithmetic involving null pointers.  However, this produces
an odd result.  A pointer variable can have bounds that are always
valid because they correspond to an actual object.  The value for
this pointer variable cannot be moved using pointer arithmetic to null
and then to another value besides null.

There is no way in the current design to express that a variable has
bounds that are always valid.  This could be addressed with
a new bounds expression:
\begin{tabbing}
\var{bounds}\=\var{-exp:} \\
\>\objectbounds{\var{bounds-exp}}{\var{bounds-exp}}
\end{tabbing}
The meaning of this bounds expression would be defined as follows:
\begin{quote}
At runtime, given an expression \var{e} with a bounds expression
\objectbounds{\var{lb}}{\var{ub}}, let the
runtime values of \var{e}, \var{lb}, and \var{ub} be \var{ev},
\var{lbv}, and \var{ubv}, respectively. The value \var{ev} will have been derived
via a sequence of operations from a pointer to some object \var{obj}
with \objectbounds{\var{low}}{\var{high}}.  The following statement 
will be true at runtime: \var{low} \lstinline@<=@ \var{lbv} \lstinline@&&@
\var{ubv} \lstinline@<=@ \var{high}.
\end{quote}
In other words, the bounds are always valid. This implies
that any access to memory where \var{lbv} \lstinline@<=@ \var{ev}
\lstinline@&&@ \var{ev} \lstinline@<@ \var{ubv} will be within the bounds of \var{obj}.

The meaning of \boundsdecl{\var{e}}{\bounds{\var{lb}}{\var{ub}}}
could be defined as \var{e} \lstinline@== 0 ||@ \objectbounds{\var{lb}}{\var{ub}}.
\objectbounds{\var{e1}}{\var{e2}} would imply \bounds{\var{e1}}{\var{e2}}.
Conversely, if some value \var{v} has \bounds{\var{e1}}{\var{e2}} and
\var{v} is not null, this would imply \objectbounds{\var{e1}}{\var{e2}}.

For variables and expressions with an \code{object_bounds}
bounds expression, runtime checks for null pointer arithmetic
would not be necessary.

It would be problematic to use \code{object_bounds} widely for
C function arguments.   Implicit in many uses of
\code{object_bounds} would be an assertion that the parameter
to which it is being applied  non-null pointer.  Consider:
\begin{lstlisting}
f(array_ptr<int> x : object_bounds(x, x + 5) {
    array_ptr<int> y = x + 1;
    ...
}
\end{lstlisting}
This risks dividing C functions into those that can
take null pointer arguments and those that only take non-null 
pointer arguments. In our experience, requirements that pointers 
not be null tend to propagate virally throughout code bases.  If an 
entire code base can be  converted, this can work well.  Otherwise, 
it results in messy dynamic checks for non-nullness in code.
Now, it is possible with lightweight invariants and \code{dynamic_check}
that such checks would not be messy.

The existing practice in C is that null pointers are widely used interchangeably
with non-null pointers.  This introduces uncertainty about the usefulness of this 
feature for C code bases.  The runtime benefit of eliminating non-null
checks in pointer arithmetic is likely small.  Following the principal of 
minimality, we have rejected the design choice of adding \code{object_bounds} 
for now. 

\section{Placement of for\_any}
\label{section:foranyalternatives}
We would have liked the placement of \forany{} to be identical for structs
and functions.  We were not able to do that. We would like a type variable to be declared 
before any use of the type variable.  This makes it easier to read and understand
code.  This means for functions that the \forany{} should precede the
return type for the function.  However, placing the \forany{} before 
a struct leads to a parsing ambiguity.  A struct may be declared inline as
part of a function definition.  It would be unclear what the \forany{} should
scope: the struct declaration or the function declaration.
\begin{verbatim}
for_any(T) int f(void);
for_any(T) struct S { T *elem, S<T> *next } g(void);
\end{verbatim}

\section{Suspends and holds clauses for structure members}

We initially proposed having a notion of \code{suspends} and \code{holds} clauses
for structure members with bounds.  This allows the programmer to annotate when
a bounds declaration for structure member is not valid and when it becomes valid.
We removed it because it is not strictly necessary and is probably better addressed
as a discussion on initialization and invariants on data.   This section contains
the proposed design.

Member bounds declaraton may be suspended for a specific
object to allow for initialization of the object or modification of the
members involved in the member bounds declarations. The member bounds
declaration is declared to hold again after the initialization or modification is done.
Here is an example of variable of type \code{S} being initialized:

\begin{lstlisting}
void f(int len) {
    S y 
    where suspends(y.data);
    array_ptr<int> newarr : count(len) = malloc(sizeof(int) * len);
    y.data = newarr;
    y.num = len
    where holds(y.data);    // the member bounds for y.data now holds
    ...
}
\end{lstlisting}

\subsection{Bounds declarations for variables with structure types}

To describe facts about members of specific variables, the left-hand
sides of bound declarations are generalized to allow members of
variables. The term \emph{variable member path} stands for variables or
variables with member accesses. Variable member paths are used where
variables were allowed:
\begin{tabbing}
\var{bounds}\=\var{-decl:}\\
\> \var{var-member-path} \code{:} \var{bounds-exp} \\
\\
\var{var-member-path:} \\
\> \var{identifier} \\
\> \var{var-member-path} \code{.} \var{identifier}
\end{tabbing}

The first identifier in a variable member path must be the name of a
variable. The rest of the path, if there is one, must
describe a member path for the structure type that has an
\arrayptr\ type. The member path can be used as a name for its
associated member bounds. Inline bounds declarations are still
restricted to variables.

\keyword{Suspends} and \keyword{holds} are dataflow-sensitive declarations of 
the states of the member bounds declarations for specific members of variables. They can be
applied to variable members that have member bounds.

They also can be applied to variables or variable members with structure
types as syntactic short-hand. In that case, they apply to the nested
members of the variable or variable member. The example could also be
written as:

\begin{lstlisting}
void f(int len) {
    S y 
    where suspends(y);
    array_ptr<int> newarr : count(len) = malloc(sizeof(int) * len))
    y.data = newarr;
    y.num = len
    where holds(y);    // the member bounds for y.data now holds
    ...
}
\end{lstlisting}

The member bounds
declaration may be suspended temporarily for specific objects while they are being
initialized or modified.

\subsection{Declaring the state of member bounds declarations for variables}

Programmers may declare the state of a member bounds declaration
for a variable using two kinds of facts:
\begin{tabbing}
\var{fact:}\= \\
\> \var{\ldots{}} \\
\> \code{suspends(}\var{var-member-path}\code{)} \\
\> \code{holds(}\var{var-member-path}\code{)}
\end{tabbing}

If the \var{var-member-path} has an \arrayptr\ type, it must
have the form \var{x.path,} where \var{x} is a variable name. 
The fact \code{suspends}(\var{x\code{.}path}\code{)} means that the
member bounds declared by the type of \var{x} for \var{path} may not
hold for \var{x}. The fact \code{holds(}\var{x\code{.}path}\code{)}
means that the member bounds declared by the type of x for \var{path}
holds now for \var{x}.

As a convenient short-hand notation, the \var{var-member-path} can have
a structure type. In that case, the declaration applies to all member
bounds for the structure type and child members of the structure type.

\subsubsection{Parameters and return values}

The state of member bounds declarations can be declared for parameters and
return values using \keyword{suspends} and \keyword{holds} as well. By
default, the state is \code{holds}.

Consider the following structure type definitions:

\begin{lstlisting}
struct S {
    array_ptr<int> data : count(num);
    int num;
}

struct T {
    S arr1;
    S arr2;
    array_ptr<float> weights : count(len);
    int len;
}
\end{lstlisting}

Here are some function declarations involving the state of member
bounds:
\begin{lstlisting}
T f(T x where holds(x)) where holds(return_value)   // the default 

T f(T x where suspends(x.arr1))
where suspends(return_value.arr2)

T f(T x where suspends(x.arr1.data)
where suspends(return_value.arr1.data)
\end{lstlisting}

\subsubsection{Extent of declarations of member bounds state for variables}
\label{section:member-bounds-state-extent}

Declarations of the state of member bounds declarations are dataflow-sensitive
and follow rules similar to flow-sensitive bounds declarations.

We first define the set of state declarations that apply to a function
component, where a function component is a statement or
variable declaration.

The state declarations for variables and variable members with structure
types are expanded to state declarations of the individual members with
\arrayptr\ type. It is assumed that declarations of automatic
structure variables without initializers implicitly have \keyword{suspends}
declarations for the variables. All other declarations of structure
variables are assumed implicitly to have \keyword{holds} declarations for the
variables. The other declarations are either automatic variables with
initializers or variables with static storage, which are initialized to
0. Any \arrayptr\ members initialized to 0 have \boundsany, so
they satisfy their member bounds declarations.

For any declaration of member bounds state for \var{v}.\var{mp}, where
\var{v} is a variable and \var{mp} is a member path, if
\begin{enumerate}
\item
  There is some path from the declaration to the function component, and
\item
  \var{v} occurs in the function component, and
\item
  There is no other declaration of member bounds state for \var{v.mp}
  along the path
\end{enumerate}
then the declaration of member bounds state applies to the function
component.

Member bounds state declarations must be consistent and agree
along all paths to a function component.   If a variable occurring in a
function component has more than one state declaration that applies to
it at the component, then all the state declarations applying to it at
the component must be syntactically identical. This avoids ambiguity
about which state declaration applies to an occurrence of a variable.
It is an error for the member bounds state declarations to disagree.

The following example illustrates the declaration of member bounds
state. The structure \code{S} represents a variable length array,
where \code{data} holds a pointer to an array and \code{num} is the 
length of the array. The function \code{f} takes a length parameter  
\code{len} and creates an initialized instance of \code{S} in the 
variable \code{y}.  It then copies \code{y} to \code{z}.

\begin{lstlisting}
struct S {
   array_ptr<int> data
   where count(data)== num;
   int num;
};
\end{lstlisting}

Here is a version of \code{f} where all member bounds state declarations are
made explicit. For structure variable members whose member bounds are
suspended, the bounds declarations are made explicit as well.

\begin{lstlisting}
void f(int len) {
    S y where suspends(y.data);
    S z where suspends(z.data);
    int i, j;
    array_ptr<int> newarr : count(len) = malloc(sizeof(int) * len);
    y.data = newarr
    where y.data : count(len);
    y.num = len
    where holds(y.data);   // the member bounds for y.data now holds
    z = y
    where holds(z.data);
}
\end{lstlisting}

This can be written more succinctly as:

\begin{lstlisting}
void f(int len) {
    S y;
    S z;
    int i, j;
    array_ptr<int> newarr : count(len) = malloc(sizeof(int) * len);
    y.data = newarr
    where y.data : count(len);
    y.num = len
    where holds(y);   // y is initialized now
    z = y
    where holds(z);   // z is initialized now
}
\end{lstlisting}

\subsection{Integration of member bounds and bounds for variables}

A member of a structure variable may be covered by its member bounds
declaration and a bounds declaration at the same time. This coexistence
happens when a member is initialized to satisfy its member bounds
declaration. Here is a version of \code{f} that is annotated with both member
bounds and bounds declarations for variable members.
\begin{lstlisting}
void f(int len) {
    S y;
    array_ptr<int> newarr : count(len) = malloc(sizeof(int) * len);
    y.data = newarr
    where newarr : count(len) and y.data : count(len);
    y.num = len
    where holds(y.data) and y.data : count(len) and 
          y.data : count(y.num);
    ...
}
\end{lstlisting}

After the assignment \code{y.num = len}, the member bounds holds for
\code{y.data} and the bounds declaration \code{y.data : count(y.num)}
holds as well.

\subsection{Determining bounds for a use of an \arrayptr\ member of a variable}
\label{section:determining-variable-member-bounds}

When a member path \var{mp} of a variable \var{x} is used and
\var{x}\code{.}\var{mp} has type \arrayptr, the bounds for
\var{x}\code{.}\var{mp} are determined using these rules:

\begin{itemize}
\item
  If the use is within the extent of a bounds declaration
  \var{x}\code{.}\var{mp} \code{:} \var{bounds-exp} and
  \var{bounds-exp} is not \boundsunknown, \var{bounds-exp} is
  the bounds.
\item
  Otherwise, if the state of the member bounds for
  \var{x}\code{.}\var{mp} is \code{holds}, the member bounds for
  \var{x}\code{.}\var{mp} is used.
\item
  Otherwise, the bounds of \var{x}\code{.}\var{mp} is
  \boundsunknown.
\end{itemize}

\subsubsection{Suspends declarations and bounds for variables.}

When the member bounds declaration \var{mb} for a variable member is
suspended by a statement of the form:

\var{e2} \keyword{where} \code{suspends(}\var{x\code{.}mp}\code{);}

where \var{x} is a variable and \var{mp} is a member path, there is an
implicit bounds declaration for \var{x}\code{.}\var{mp} at the point
of suspension. This happens unless \var{e2} modifies a member \var{m}
of \var{x} that occurs in \var{mb}. In addition, the state of the
member bounds for \var{x}\code{.}\var{mp} must be \code{holds}
before the statement. The member bounds declaration \var{mb} is
converted to a bounds declaration by prefixing each occurrence of a
member path in \var{mb} with the expression ``\var{x}\code{.}''.

For example, given

\begin{lstlisting}
S copy_and_resize(S arg, int len) {
    array_ptr<int> newarr : count(len) = malloc(sizeof(int) * len)
       where suspends(arg);
    for (int i = 0; i < arg.num; i++) {
       newarr[i] = arg.data[i];
    }
    arg.data = newarr where arg.data : count(len);
    arg.num = len where arg.data : count(arg.num)
    where holds(arg);   // member bounds for arg holds now
    return arg;
}
\end{lstlisting}


There is implicitly a bounds declaration at the suspension of the member
bounds for arg:

\begin{lstlisting}
    array_ptr<int> newarr : count(len) = malloc(sizeof(int) * len)
       where suspends(arg) and arg.data : count(arg.num);
\end{lstlisting}

If the suspends were done after the assignment to \code{arg.data}:

\begin{lstlisting}
    arg.data = newarr
    suspends(arg);
\end{lstlisting}

there would not be an implicit bounds declaration because \code{arg.data} is
modified by the assignment.

At a declaration of a structure variable x, no implicit bounds
declarations are inserted if the declaration suspends the member bounds
for a member of x. There was no point at which the member bounds was
known to be true. For example,

\begin{lstlisting}
f(S arg where suspends(arg))
\end{lstlisting}

does not have an implicit bounds declaration of the form \lstinline|arg.data :count(arg.len)|.

\subsubsection{Holds declarations and bounds for variables}

At a \keyword{holds} declaration for a variable member path \var{x.mp},
the member bounds for \var{x.mp} must be implied by the bounds
declarations that are true about members of \var{x} and any facts that 
true at the point of the \keyword{holds} declaration.





