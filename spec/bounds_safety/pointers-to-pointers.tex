% !Tex root = checkedc.tex

\chapter{Pointers to data that contains \plainarrayptr s}
\label{chapter:pointers-to-data-with-arrayptrs}

This chapter covers using pointers to data with \arrayptr s.  It also covers rules
around pointers and bounds expressions.  This includes dereferencing pointers
in bounds expressions and rules around address-taken pointer variables and
bounds expressions..
Three important scenarios for using pointers to \arrayptr s to support are:
\begin{itemize}
\item Data structures: All linked data structures in 
C are built with pointers, typically using pointers to structures.   This means
there need to be ways to create pointers to structures that contain \arrayptr s,
to assign through pointers to structures, and to read from pointers to structures.
\item Passing data by-reference to functions.  C does not provide by-reference
parameters.  Programmers pass data by-reference by using pointers explicitly.
To pass data of type \var{T} by reference, a programmer creates a parameter
with type \var{T *}.  Using checked pointers, a programmer create a parameter
with type \ptrT.
\item Taking the addresses of variables.  In C, programmers may take the
addresses of variables.  Typically, this is done to be pass data by-reference.
If a variable is used in a bounds expression, what can be done with the pointer
must be constrained so that bounds-safety is not accidentally broken.
\end{itemize}

\section{Initialization of pointers in data}

The term ``referent data'' will refer to the data that can be accessed
directly through a pointer.  The data may be an integer or floating-point number, a structure,
a pointer, or an array of data.   Any checked pointers in data must be initialized
before the pointers are used.

For variables, this can be enforced using a static 
analysis of variables with checked pointer types that point to data with checked
pointer types. For example, the Cyclone dialect of C \cite{Jim2002} did this
and languages like Java and C\# have rules for ensuring that variables
are definitely assigned before they are used.
For a variable of \arrayptr\ data, the compiler will insert code for 
initializing checked pointers in the data automatically to \code{0}, which is always
a valid pointer.    

  Section~\ref{section:allocation-of-uninitialized-data} 
describes a proposal for supporting for allocators that return pointers to
uninitialized data.
 
\section{Pointers to structures}

Pointers to  structures can be supported by ensuring that modifications to members
preserve type-level bounds invariants, following the approach of the Deputy
system \cite{Condit2007}.  This in turn means that accesses through structure
pointers return values that  follow the type-level bounds invariants, provided that modifications
are not interleaved.  Complicated aliasing problems are avoided because the
alias relationship of members within a structure is well-known.  Expressions
and statements that modify members must be relatively simple; they cannot access memory
that may be aliased.

Just like a member bounds can be suspended for a variable, a member bounds can 
be suspended for an object that is referenced by a pointer. The syntax is:

\begin{tabbing}
\var{fact:}\= \\
\>\code{suspends(}\var{e}\code{->}\var{mp}\code{)} \\
\>\code{holds(}\var{e}\code{->}\var{mp}\code{)} \\
\end{tabbing}

where \var{e} is a pointer to a structure type \var{S} and \var{mp} is a member of
path.  The syntax \code{(*}\var{e}\code{.}\var{mp} is equivalent to 
\var{e}\code{->}\var{mp} and can be used in its place.  
The syntax \code{suspends(*}\var{e}\code{)} suspends all member bounds for 
the object pointed to by \var{e} and the syntax \code{holds(*}\var{e}\code{)} 
means that all member bounds for \var{e} must hold.

The expression \var{e} must be a non-modifying expression to ensure that the \var{e}
refers to the same object at \keyword{suspends} and \keyword{holds} declarations.
It must meet the following additional restrictions:
\begin{itemize}
\item \var{e} cannot access memory via a pointer operation.
      It cannot contain a \code{*}, \code{->},  or a \code{[]} operation.
\item No variable whose value is used \var{e} can be modified between the \code{suspends}
and \code{holds} declarations.
\item No variable whose value is used in \var{e} can have its address taken. 
This is to avoid indirect modifications of variables.
\end{itemize}

There are additional restrictions to avoid problems due to pointer aliasing 
(when two pointers may point to the same memory).   We propose simple restrictions
for correctness.
Function calls are not allowed between \keyword{suspends} and 
\keyword{holds} declarations for \var{e}\code{->}\var{mp}.  The function calls 
might depend on the object pointed to by \var{e} having a  valid type-level invariant.
  
We continue to assume that the addresses of \arrayptr\ members and members
used in member bounds cannot be taken.  It is undefined behavior for unchecked
code to create pointers to the memory of those members.   With this assumption, we 
can allow assignments through and reads via other pointer expressions
between the \keyword{suspends} and \keyword{holds} declarations for
\var{e}\code{->}\var{mp}.  This is provided that the assignments do not modify 
\var{S}\code{.}\var{mp} or members in the bounds of \var{S}\code{.}\var{mp}.  No pointers should alias
\var{mp} or the other members, so the only aliases can be other structure
pointers.  Those can only be created through casting.  It is the programmer's responsibility
to update bounds-checked members properly in that case (Section~\ref{section:pointer-casting}).

