% !Tex root = checkedc.tex

\chapter{Pointers to data that contains \plainarrayptr s}
\label{chapter:pointers-to-data-with-arrayptrs}

This chapter covers using pointers to data with \arrayptr s.  It also covers rules
around pointers and bounds expressions.  This includes dereferencing pointers
in bounds expressions and rules around address-taken pointer variables and
bounds expressions..
Three important scenarios for using pointers to \arrayptr s to support are:
\begin{itemize}
\item Data structures: All linked data structures in 
C are built with pointers, typically using pointers to structures.   This means
there need to be ways to create pointers to structures that contain \arrayptr s,
to assign through pointers to structures, and to read from pointers to structures.
\item Passing data by-reference to functions.  C does not provide by-reference
parameters.  Programmers pass data by-reference by using pointers explicitly.
To pass data of type \var{T} by reference, a programmer creates a parameter
with type \var{T *}.  Using checked pointers, a programmer create a parameter
with type \ptrT.
\item Taking the addresses of variables.  In C, programmers may take the
addresses of variables.  Typically, this is done to be pass data by-reference.
If a variable is used in a bounds expression, what can be done with the pointer
must be constrained so that bounds-safety is not accidentally broken.
\end{itemize}

\section{Initialization of pointers in data}

The term ``referent data'' will refer to the data that can be accessed
directly through a pointer.  The data may be an integer or floating-point number, a structure,
a pointer, or an array of data.   Any checked pointers in data must be initialized
before the pointers are used.

For variables, this can be enforced using a static 
analysis of variables with checked pointer types that point to data with checked
pointer types. For example, the Cyclone dialect of C \cite{Jim2002} did this
and languages like Java and C\# have rules for ensuring that variables
are definitely assigned before they are used.
For a variable of \arrayptr\ data, the compiler will insert code for 
initializing checked pointers in the data automatically to \code{0}, which is always
a valid pointer.    

  Section~\ref{section:allocation-of-uninitialized-data} 
describes a proposal for supporting for allocators that return pointers to
uninitialized data.
 
\section{Pointers to structures}

Pointers to  structures can be supported by ensuring that modifications to members
preserve type-level bounds invariants, following the approach of the Deputy
system \cite{Condit2007}.  This in turn means that member accesses via structure
pointers produce values that follow the type-level bounds invariants.  
Complicated aliasing problems are avoided because the
alias relationship of members within a structure is well-known.

Checked C requires that type-level bounds invariants hold after each expression
statement or bundled block and before any function calls.  For type-level bounds
invariants involving multiple members, the code for updating members accessed
via structure pointers must be fairly simple because of possible aliasing issues.
\begin{itemize}
\item It must be possible to prove that the base expressions used in the
member assignments produce the same ponter value.  One case is that the same
non-modifiable base expression is used in the member assignments  (given
var{e}\code{.}\var{m}, e is the base expression).
\item There cannot be any function calls.  An exception to this is if the memory
for the structure is known to be newly allocated (and cannot possibly be aliased).
\item There cannot be any memory accesses via any other pointers that might alias
the pointer being used for the update.
\end{itemize}


